/**
 * Linux-specific bridge for Bitcoin Solo Miner Monitor Installer
 * 
 * This module provides communication between the Electron wizard and the Linux DEB/RPM installers.
 */

const { spawn, exec } = require('child_process');
const path = require('path');
const fs = require('fs');
const os = require('os');
const sudo = require('sudo-prompt');

/**
 * Launch Linux installer with parameters from Electron wizard
 * 
 * @param {Object} config - Configuration object from the wizard
 * @returns {Promise} - Promise that resolves when installation is complete
 */
async function launchLinuxInstaller(config) {
  return new Promise((resolve, reject) => {
    try {
      // Create a temporary file to store the configuration
      const tempConfigPath = path.join(os.tmpdir(), 'bsmm_installer_config.json');
      
      // Write configuration to temp file
      fs.writeFileSync(tempConfigPath, JSON.stringify(config, null, 2));
      
      // Determine which package to use based on the Linux distribution
      const packageType = getLinuxPackageType();
      let installerPath;
      
      if (packageType === 'deb') {
        installerPath = path.join(__dirname, '..', 'linux', 'bitcoin-solo-miner-monitor_0.1.0_amd64.deb');
      } else if (packageType === 'rpm') {
        installerPath = path.join(__dirname, '..', 'linux', 'bitcoin-solo-miner-monitor-0.1.0-1.x86_64.rpm');
      } else {
        throw new Error(`Unsupported Linux distribution: ${packageType}`);
      }
      
      // Check if installer exists
      if (!fs.existsSync(installerPath)) {
        throw new Error(`Linux installer not found at ${installerPath}`);
      }
      
      // Create a pre-installation script with configuration
      const preInstallScript = `#!/bin/bash
# This script is generated by the Electron installer wizard

# Create configuration directory
sudo mkdir -p /etc/bitcoin-solo-miner-monitor

# Create first run configuration
cat << EOF | sudo tee /etc/bitcoin-solo-miner-monitor/first_run.ini
[NetworkDiscovery]
Enabled=${config.autoDiscovery ? 1 : 0}
Range=${config.networkRange}

[Installation]
InstallDir=${config.installDir}
DataDir=${config.dataDir}
StartOnBoot=${config.startOnBoot ? 1 : 0}

[Components]
Core=1
Database=${config.components?.database ? 1 : 0}
Dashboard=${config.components?.dashboard ? 1 : 0}
Alert=${config.components?.alert ? 1 : 0}
API=${config.components?.api ? 1 : 0}
Documentation=${config.components?.docs ? 1 : 0}
EOF

# Set permissions
sudo chmod 644 /etc/bitcoin-solo-miner-monitor/first_run.ini
`;
      
      // Write the pre-installation script to a temporary file
      const preInstallPath = path.join(os.tmpdir(), 'bsmm_pre_install.sh');
      fs.writeFileSync(preInstallPath, preInstallScript);
      fs.chmodSync(preInstallPath, '755');
      
      // Run the pre-installation script with sudo
      sudo.exec(preInstallPath, { name: 'Bitcoin Solo Miner Monitor Installer' }, (error) => {
        if (error) {
          reject(new Error(`Failed to run pre-installation script: ${error.message}`));
          return;
        }
        
        // Install the package
        let installCommand;
        if (packageType === 'deb') {
          installCommand = `sudo dpkg -i "${installerPath}" && sudo apt-get install -f`;
        } else {
          installCommand = `sudo rpm -i "${installerPath}"`;
        }
        
        sudo.exec(installCommand, { name: 'Bitcoin Solo Miner Monitor Installer' }, (error) => {
          // Clean up temporary files
          try {
            fs.unlinkSync(tempConfigPath);
            fs.unlinkSync(preInstallPath);
          } catch (err) {
            console.warn('Could not remove temp files:', err.message);
          }
          
          if (error) {
            reject(new Error(`Failed to install package: ${error.message}`));
          } else {
            resolve({ success: true });
          }
        });
      });
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * Determine the Linux package type based on the distribution
 * 
 * @returns {string} - Package type ('deb' or 'rpm')
 */
function getLinuxPackageType() {
  try {
    // Check for Debian/Ubuntu
    if (fs.existsSync('/etc/debian_version')) {
      return 'deb';
    }
    
    // Check for RHEL/CentOS/Fedora
    if (fs.existsSync('/etc/redhat-release') || fs.existsSync('/etc/fedora-release')) {
      return 'rpm';
    }
    
    // Check for other RPM-based distributions
    if (fs.existsSync('/usr/bin/rpm')) {
      return 'rpm';
    }
    
    // Default to DEB if we can't determine
    return 'deb';
  } catch (error) {
    console.error(`Error determining Linux package type: ${error.message}`);
    return 'deb'; // Default to DEB
  }
}

/**
 * Update the Linux package creation script to include the Electron wizard configuration
 * 
 * @param {string} scriptPath - Path to the package creation script
 * @returns {Promise} - Promise that resolves when the script is updated
 */
async function updateLinuxScript(scriptPath) {
  try {
    // Read the package creation script
    const script = await fs.promises.readFile(scriptPath, 'utf8');
    
    // Update the script to include the Electron wizard configuration
    const updatedScript = script
      // Add support for configuration file
      .replace(
        '# Create post-installation script for .deb',
        `# Check for configuration file
if [ -n "$1" ] && [ -f "$1" ]; then
  CONFIG_FILE="$1"
  echo "Using configuration file: $CONFIG_FILE"
  
  # Extract configuration values
  NETWORK_DISCOVERY_ENABLED=$(grep -A 1 "\\[NetworkDiscovery\\]" "$CONFIG_FILE" | grep "Enabled" | cut -d= -f2)
  NETWORK_RANGE=$(grep -A 2 "\\[NetworkDiscovery\\]" "$CONFIG_FILE" | grep "Range" | cut -d= -f2)
  
  # Extract component selections
  COMPONENT_DATABASE=$(grep -A 6 "\\[Components\\]" "$CONFIG_FILE" | grep "Database" | cut -d= -f2)
  COMPONENT_DASHBOARD=$(grep -A 6 "\\[Components\\]" "$CONFIG_FILE" | grep "Dashboard" | cut -d= -f2)
  COMPONENT_ALERT=$(grep -A 6 "\\[Components\\]" "$CONFIG_FILE" | grep "Alert" | cut -d= -f2)
  COMPONENT_API=$(grep -A 6 "\\[Components\\]" "$CONFIG_FILE" | grep "API" | cut -d= -f2)
  COMPONENT_DOCS=$(grep -A 6 "\\[Components\\]" "$CONFIG_FILE" | grep "Documentation" | cut -d= -f2)
else
  # Default values
  NETWORK_DISCOVERY_ENABLED=1
  NETWORK_RANGE="192.168.1.0/24"
  COMPONENT_DATABASE=1
  COMPONENT_DASHBOARD=1
  COMPONENT_ALERT=1
  COMPONENT_API=1
  COMPONENT_DOCS=1
fi

# Create post-installation script for .deb`
      )
      // Update the first_run.ini creation
      .replace(
        'cat > "/etc/${APP_NAME}/first_run.ini" << CONFIG\n[NetworkDiscovery]\nEnabled=1\nRange=192.168.1.0/24\nCONFIG',
        `cat > "/etc/\${APP_NAME}/first_run.ini" << CONFIG
[NetworkDiscovery]
Enabled=\${NETWORK_DISCOVERY_ENABLED}
Range=\${NETWORK_RANGE}

[Components]
Core=1
Database=\${COMPONENT_DATABASE}
Dashboard=\${COMPONENT_DASHBOARD}
Alert=\${COMPONENT_ALERT}
API=\${COMPONENT_API}
Documentation=\${COMPONENT_DOCS}
CONFIG`
      );
    
    // Write the updated script
    await fs.promises.writeFile(scriptPath, updatedScript);
    
    return { success: true };
  } catch (error) {
    console.error(`Error updating Linux script: ${error.message}`);
    throw error;
  }
}

module.exports = {
  launchLinuxInstaller,
  updateLinuxScript
};