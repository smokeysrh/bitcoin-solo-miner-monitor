#!/usr/bin/env python3
"""
Vulnerability Detection System
Detects and reports security vulnerabilities in dependencies and build artifacts
"""

import os
import sys
import json
import requests
import subprocess
import argparse
import logging
from pathlib import Path
from typing import Dict, List, Optional, Set
from datetime import datetime, timedelta
import tempfile
import re

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class VulnerabilityDetector:
    """Detects vulnerabilities in dependencies and build artifacts"""
    
    def __init__(self, cache_dir: str = ".vulnerability-cache"):
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(exist_ok=True)
        self.vulnerability_db = {}
        self.scan_results = {}
        
    def scan_python_dependencies(self, requirements_file: str = None) -> Dict:
        """Scan Python dependencies for known vulnerabilities"""
        logger.info("[PYTHON] Scanning Python dependencies for vulnerabilities...")
        
        result = {
            "scan_type": "python_dependencies",
            "timestamp": datetime.now().isoformat(),
            "vulnerabilities": [],
            "summary": {"total": 0, "high": 0, "medium": 0, "low": 0},
            "tools_used": []
        }
        
        # Use Safety to scan Python dependencies
        if self._check_tool_available("safety"):
            safety_result = self._run_safety_scan(requirements_file)
            result["vulnerabilities"].extend(safety_result["vulnerabilities"])
            result["tools_used"].append("safety")
            
        # Use pip-audit if available
        if self._check_tool_available("pip-audit"):
            audit_result = self._run_pip_audit(requirements_file)
            result["vulnerabilities"].extend(audit_result["vulnerabilities"])
            result["tools_used"].append("pip-audit")
            
        # Update summary
        result["summary"] = self._calculate_summary(result["vulnerabilities"])
        
        return result
        
    def scan_nodejs_dependencies(self, package_json_dir: str = None) -> Dict:
        """Scan Node.js dependencies for known vulnerabilities"""
        logger.info("[NODEJS] Scanning Node.js dependencies for vulnerabilities...")
        
        result = {
            "scan_type": "nodejs_dependencies", 
            "timestamp": datetime.now().isoformat(),
            "vulnerabilities": [],
            "summary": {"total": 0, "high": 0, "medium": 0, "low": 0},
            "tools_used": []
        }
        
        # Use npm audit
        if self._check_tool_available("npm"):
            npm_result = self._run_npm_audit(package_json_dir)
            result["vulnerabilities"].extend(npm_result["vulnerabilities"])
            result["tools_used"].append("npm-audit")
            
        # Use yarn audit if available
        if self._check_tool_available("yarn"):
            yarn_result = self._run_yarn_audit(package_json_dir)
            result["vulnerabilities"].extend(yarn_result["vulnerabilities"])
            result["tools_used"].append("yarn-audit")
            
        # Update summary
        result["summary"] = self._calculate_summary(result["vulnerabilities"])
        
        return result
        
    def scan_system_dependencies(self) -> Dict:
        """Scan system-level dependencies and tools"""
        logger.info("[SYSTEM] Scanning system dependencies for vulnerabilities...")
        
        result = {
            "scan_type": "system_dependencies",
            "timestamp": datetime.now().isoformat(),
            "vulnerabilities": [],
            "summary": {"total": 0, "high": 0, "medium": 0, "low": 0},
            "system_info": self._get_system_info()
        }
        
        # Check for known vulnerable system components
        system_vulns = self._check_system_vulnerabilities()
        result["vulnerabilities"].extend(system_vulns)
        
        # Update summary
        result["summary"] = self._calculate_summary(result["vulnerabilities"])
        
        return result
        
    def _check_tool_available(self, tool_name: str) -> bool:
        """Check if a security tool is available"""
        try:
            subprocess.run([tool_name, "--version"], 
                         capture_output=True, 
                         timeout=10)
            return True
        except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.CalledProcessError):
            return False
            
    def _run_safety_scan(self, requirements_file: str = None) -> Dict:
        """Run Safety scan for Python vulnerabilities"""
        result = {"vulnerabilities": []}
        
        try:
            cmd = ["safety", "check", "--json"]
            if requirements_file and Path(requirements_file).exists():
                cmd.extend(["-r", requirements_file])
                
            process = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            if process.stdout:
                try:
                    safety_data = json.loads(process.stdout)
                    
                    for vuln in safety_data:
                        vulnerability = {
                            "source": "safety",
                            "package": vuln.get("package_name", "unknown"),
                            "version": vuln.get("analyzed_version", "unknown"),
                            "vulnerability_id": vuln.get("vulnerability_id", "unknown"),
                            "severity": self._map_safety_severity(vuln.get("vulnerability_id", "")),
                            "title": vuln.get("advisory", "Unknown vulnerability"),
                            "description": vuln.get("advisory", ""),
                            "cve": self._extract_cve_from_advisory(vuln.get("advisory", "")),
                            "fixed_versions": vuln.get("specs", []),
                            "more_info_url": vuln.get("more_info_url", "")
                        }
                        result["vulnerabilities"].append(vulnerability)
                        
                except json.JSONDecodeError:
                    logger.warning("Could not parse Safety JSON output")
                    
        except subprocess.TimeoutExpired:
            logger.warning("Safety scan timed out")
        except Exception as e:
            logger.warning(f"Safety scan failed: {str(e)}")
            
        return result
        
    def _run_pip_audit(self, requirements_file: str = None) -> Dict:
        """Run pip-audit scan for Python vulnerabilities"""
        result = {"vulnerabilities": []}
        
        try:
            cmd = ["pip-audit", "--format=json"]
            if requirements_file and Path(requirements_file).exists():
                cmd.extend(["-r", requirements_file])
                
            process = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            if process.stdout:
                try:
                    audit_data = json.loads(process.stdout)
                    
                    for vuln in audit_data.get("vulnerabilities", []):
                        vulnerability = {
                            "source": "pip-audit",
                            "package": vuln.get("package", "unknown"),
                            "version": vuln.get("version", "unknown"),
                            "vulnerability_id": vuln.get("id", "unknown"),
                            "severity": self._map_pip_audit_severity(vuln),
                            "title": vuln.get("description", "Unknown vulnerability"),
                            "description": vuln.get("description", ""),
                            "cve": vuln.get("id", "") if vuln.get("id", "").startswith("CVE-") else "",
                            "fixed_versions": vuln.get("fix_versions", []),
                            "more_info_url": ""
                        }
                        result["vulnerabilities"].append(vulnerability)
                        
                except json.JSONDecodeError:
                    logger.warning("Could not parse pip-audit JSON output")
                    
        except subprocess.TimeoutExpired:
            logger.warning("pip-audit scan timed out")
        except Exception as e:
            logger.warning(f"pip-audit scan failed: {str(e)}")
            
        return result
        
    def _run_npm_audit(self, package_json_dir: str = None) -> Dict:
        """Run npm audit for Node.js vulnerabilities"""
        result = {"vulnerabilities": []}
        
        try:
            cwd = package_json_dir if package_json_dir else "."
            
            process = subprocess.run(
                ["npm", "audit", "--json"],
                capture_output=True,
                text=True,
                timeout=120,
                cwd=cwd
            )
            
            if process.stdout:
                try:
                    audit_data = json.loads(process.stdout)
                    
                    # Handle npm audit v7+ format
                    if "vulnerabilities" in audit_data:
                        for pkg_name, vuln_data in audit_data["vulnerabilities"].items():
                            vulnerability = {
                                "source": "npm-audit",
                                "package": pkg_name,
                                "version": vuln_data.get("range", "unknown"),
                                "vulnerability_id": "",
                                "severity": vuln_data.get("severity", "unknown"),
                                "title": vuln_data.get("title", "Unknown vulnerability"),
                                "description": vuln_data.get("overview", ""),
                                "cve": "",
                                "fixed_versions": [],
                                "more_info_url": vuln_data.get("url", "")
                            }
                            result["vulnerabilities"].append(vulnerability)
                            
                    # Handle older npm audit format
                    elif "advisories" in audit_data:
                        for advisory_id, advisory in audit_data["advisories"].items():
                            vulnerability = {
                                "source": "npm-audit",
                                "package": advisory.get("module_name", "unknown"),
                                "version": advisory.get("vulnerable_versions", "unknown"),
                                "vulnerability_id": advisory_id,
                                "severity": advisory.get("severity", "unknown"),
                                "title": advisory.get("title", "Unknown vulnerability"),
                                "description": advisory.get("overview", ""),
                                "cve": advisory.get("cves", [""])[0] if advisory.get("cves") else "",
                                "fixed_versions": advisory.get("patched_versions", "").split(" || "),
                                "more_info_url": advisory.get("url", "")
                            }
                            result["vulnerabilities"].append(vulnerability)
                            
                except json.JSONDecodeError:
                    logger.warning("Could not parse npm audit JSON output")
                    
        except subprocess.TimeoutExpired:
            logger.warning("npm audit timed out")
        except Exception as e:
            logger.warning(f"npm audit failed: {str(e)}")
            
        return result
        
    def _run_yarn_audit(self, package_json_dir: str = None) -> Dict:
        """Run yarn audit for Node.js vulnerabilities"""
        result = {"vulnerabilities": []}
        
        try:
            cwd = package_json_dir if package_json_dir else "."
            
            process = subprocess.run(
                ["yarn", "audit", "--json"],
                capture_output=True,
                text=True,
                timeout=120,
                cwd=cwd
            )
            
            if process.stdout:
                # Yarn audit outputs NDJSON (newline-delimited JSON)
                for line in process.stdout.strip().split('\n'):
                    if line.strip():
                        try:
                            audit_item = json.loads(line)
                            
                            if audit_item.get("type") == "auditAdvisory":
                                data = audit_item.get("data", {})
                                advisory = data.get("advisory", {})
                                
                                vulnerability = {
                                    "source": "yarn-audit",
                                    "package": advisory.get("module_name", "unknown"),
                                    "version": advisory.get("vulnerable_versions", "unknown"),
                                    "vulnerability_id": str(advisory.get("id", "unknown")),
                                    "severity": advisory.get("severity", "unknown"),
                                    "title": advisory.get("title", "Unknown vulnerability"),
                                    "description": advisory.get("overview", ""),
                                    "cve": advisory.get("cves", [""])[0] if advisory.get("cves") else "",
                                    "fixed_versions": advisory.get("patched_versions", "").split(" || "),
                                    "more_info_url": advisory.get("url", "")
                                }
                                result["vulnerabilities"].append(vulnerability)
                                
                        except json.JSONDecodeError:
                            continue  # Skip malformed lines
                            
        except subprocess.TimeoutExpired:
            logger.warning("yarn audit timed out")
        except Exception as e:
            logger.warning(f"yarn audit failed: {str(e)}")
            
        return result
        
    def _check_system_vulnerabilities(self) -> List[Dict]:
        """Check for known system-level vulnerabilities"""
        vulnerabilities = []
        
        # This is a placeholder for system-level vulnerability checks
        # In a real implementation, you might check:
        # - OS version against known CVEs
        # - Installed system packages
        # - Docker base images
        # - Build tools versions
        
        return vulnerabilities
        
    def _get_system_info(self) -> Dict:
        """Get system information for vulnerability context"""
        import platform
        
        return {
            "platform": platform.platform(),
            "system": platform.system(),
            "release": platform.release(),
            "version": platform.version(),
            "machine": platform.machine(),
            "processor": platform.processor(),
            "python_version": platform.python_version()
        }
        
    def _map_safety_severity(self, vuln_id: str) -> str:
        """Map Safety vulnerability ID to severity level"""
        # Safety doesn't provide severity directly, so we use heuristics
        # In practice, you might maintain a mapping or use external APIs
        return "medium"  # Default severity
        
    def _map_pip_audit_severity(self, vuln_data: Dict) -> str:
        """Map pip-audit vulnerability data to severity level"""
        # pip-audit may include severity information
        return vuln_data.get("severity", "medium")
        
    def _extract_cve_from_advisory(self, advisory_text: str) -> str:
        """Extract CVE ID from advisory text"""
        cve_pattern = r'CVE-\d{4}-\d{4,}'
        match = re.search(cve_pattern, advisory_text)
        return match.group(0) if match else ""
        
    def _calculate_summary(self, vulnerabilities: List[Dict]) -> Dict:
        """Calculate vulnerability summary statistics"""
        summary = {"total": len(vulnerabilities), "high": 0, "medium": 0, "low": 0}
        
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "unknown").lower()
            if severity in ["high", "critical"]:
                summary["high"] += 1
            elif severity == "medium":
                summary["medium"] += 1
            elif severity == "low":
                summary["low"] += 1
                
        return summary
        
    def generate_vulnerability_report(self, scan_results: List[Dict], output_dir: str = "security-reports") -> str:
        """Generate comprehensive vulnerability report"""
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = output_path / f"vulnerability_report_{timestamp}.json"
        
        report_data = {
            "report_metadata": {
                "timestamp": datetime.now().isoformat(),
                "scanner_version": "1.0.0",
                "scan_types": [result["scan_type"] for result in scan_results]
            },
            "scan_results": scan_results,
            "consolidated_summary": self._consolidate_summaries(scan_results),
            "recommendations": self._generate_recommendations(scan_results)
        }
        
        with open(report_file, 'w') as f:
            json.dump(report_data, f, indent=2)
            
        logger.info(f"📄 Vulnerability report generated: {report_file}")
        
        # Also generate markdown report
        md_report_file = output_path / f"vulnerability_report_{timestamp}.md"
        with open(md_report_file, 'w') as f:
            f.write(self._generate_markdown_vulnerability_report(report_data))
            
        return str(report_file)
        
    def _consolidate_summaries(self, scan_results: List[Dict]) -> Dict:
        """Consolidate summaries from multiple scans"""
        consolidated = {"total": 0, "high": 0, "medium": 0, "low": 0, "by_scan_type": {}}
        
        for result in scan_results:
            summary = result.get("summary", {})
            scan_type = result.get("scan_type", "unknown")
            
            consolidated["total"] += summary.get("total", 0)
            consolidated["high"] += summary.get("high", 0)
            consolidated["medium"] += summary.get("medium", 0)
            consolidated["low"] += summary.get("low", 0)
            
            consolidated["by_scan_type"][scan_type] = summary
            
        return consolidated
        
    def _generate_recommendations(self, scan_results: List[Dict]) -> List[str]:
        """Generate security recommendations based on scan results"""
        recommendations = []
        
        total_vulns = sum(result.get("summary", {}).get("total", 0) for result in scan_results)
        high_vulns = sum(result.get("summary", {}).get("high", 0) for result in scan_results)
        
        if high_vulns > 0:
            recommendations.append(f"🚨 Address {high_vulns} high-severity vulnerabilities immediately")
            recommendations.append("Consider delaying release until critical vulnerabilities are resolved")
            
        if total_vulns > 0:
            recommendations.append("Update dependencies to latest secure versions")
            recommendations.append("Review and apply security patches")
            recommendations.append("Consider using dependency pinning for production builds")
            
        recommendations.extend([
            "Implement automated vulnerability scanning in CI/CD pipeline",
            "Set up security monitoring and alerting",
            "Regularly update security scanning tools and databases",
            "Document security update procedures for the community"
        ])
        
        return recommendations
        
    def _generate_markdown_vulnerability_report(self, report_data: Dict) -> str:
        """Generate markdown format vulnerability report"""
        lines = [
            "# Vulnerability Scan Report",
            f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "## Executive Summary",
            ""
        ]
        
        summary = report_data["consolidated_summary"]
        
        if summary["total"] == 0:
            lines.extend([
                "✅ **No vulnerabilities detected**",
                "",
                "All scanned dependencies appear to be secure based on current vulnerability databases.",
                ""
            ])
        else:
            lines.extend([
                f"⚠️ **{summary['total']} vulnerabilities detected**",
                "",
                f"- 🔴 **High Severity:** {summary['high']}",
                f"- 🟡 **Medium Severity:** {summary['medium']}",
                f"- 🟢 **Low Severity:** {summary['low']}",
                ""
            ])
            
        # Add scan type breakdown
        lines.extend([
            "## Scan Results by Type",
            ""
        ])
        
        for scan_type, type_summary in summary["by_scan_type"].items():
            lines.extend([
                f"### {scan_type.replace('_', ' ').title()}",
                f"- Total: {type_summary['total']}",
                f"- High: {type_summary['high']}",
                f"- Medium: {type_summary['medium']}",
                f"- Low: {type_summary['low']}",
                ""
            ])
            
        # Add detailed vulnerabilities
        if summary["total"] > 0:
            lines.extend([
                "## Detailed Vulnerabilities",
                ""
            ])
            
            for scan_result in report_data["scan_results"]:
                if scan_result.get("vulnerabilities"):
                    lines.append(f"### {scan_result['scan_type'].replace('_', ' ').title()}")
                    lines.append("")
                    
                    for vuln in scan_result["vulnerabilities"]:
                        severity_emoji = {
                            "high": "🔴",
                            "critical": "🔴", 
                            "medium": "🟡",
                            "low": "🟢"
                        }.get(vuln.get("severity", "").lower(), "⚪")
                        
                        lines.extend([
                            f"#### {severity_emoji} {vuln['package']} ({vuln['version']})",
                            f"**Severity:** {vuln['severity']}",
                            f"**Title:** {vuln['title']}",
                            ""
                        ])
                        
                        if vuln.get("description"):
                            lines.extend([
                                f"**Description:** {vuln['description']}",
                                ""
                            ])
                            
                        if vuln.get("cve"):
                            lines.extend([
                                f"**CVE:** {vuln['cve']}",
                                ""
                            ])
                            
                        if vuln.get("fixed_versions"):
                            lines.extend([
                                f"**Fixed in:** {', '.join(vuln['fixed_versions'])}",
                                ""
                            ])
                            
                        if vuln.get("more_info_url"):
                            lines.extend([
                                f"**More Info:** {vuln['more_info_url']}",
                                ""
                            ])
                            
                        lines.append("---")
                        lines.append("")
                        
        # Add recommendations
        lines.extend([
            "## Recommendations",
            ""
        ])
        
        for rec in report_data["recommendations"]:
            lines.append(f"- {rec}")
            
        return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(description="Vulnerability detector for dependencies")
    parser.add_argument("--python", action="store_true", help="Scan Python dependencies")
    parser.add_argument("--nodejs", action="store_true", help="Scan Node.js dependencies")
    parser.add_argument("--system", action="store_true", help="Scan system dependencies")
    parser.add_argument("--all", action="store_true", help="Scan all dependency types")
    parser.add_argument("--requirements", help="Path to requirements.txt file")
    parser.add_argument("--package-json-dir", help="Directory containing package.json")
    parser.add_argument("--output-dir", default="security-reports", help="Output directory for reports")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
        
    if not any([args.python, args.nodejs, args.system, args.all]):
        parser.error("Must specify at least one scan type (--python, --nodejs, --system, or --all)")
        
    detector = VulnerabilityDetector()
    scan_results = []
    
    if args.all or args.python:
        python_result = detector.scan_python_dependencies(args.requirements)
        scan_results.append(python_result)
        print(f"🐍 Python: {python_result['summary']['total']} vulnerabilities found")
        
    if args.all or args.nodejs:
        nodejs_result = detector.scan_nodejs_dependencies(args.package_json_dir)
        scan_results.append(nodejs_result)
        print(f"📦 Node.js: {nodejs_result['summary']['total']} vulnerabilities found")
        
    if args.all or args.system:
        system_result = detector.scan_system_dependencies()
        scan_results.append(system_result)
        print(f"🔧 System: {system_result['summary']['total']} vulnerabilities found")
        
    if scan_results:
        report_file = detector.generate_vulnerability_report(scan_results, args.output_dir)
        print(f"\n📄 Report generated: {report_file}")
        
        # Check for critical vulnerabilities
        total_high = sum(result.get("summary", {}).get("high", 0) for result in scan_results)
        if total_high > 0:
            print(f"🚨 {total_high} high-severity vulnerabilities found!")
            sys.exit(1)
        else:
            print("✅ No high-severity vulnerabilities detected")


if __name__ == "__main__":
    main()