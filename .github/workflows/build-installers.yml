name: Build Installers

on:
  push:
    tags:
      - 'v*'
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., 1.0.0)'
        required: false
        default: 'dev-build'

env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'

jobs:
  build-windows:
    runs-on: windows-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Determine version
      id: version
      run: |
        if ("${{ github.event_name }}" -eq "push" -and "${{ github.ref }}" -like "refs/tags/v*") {
          $version = "${{ github.ref }}" -replace "refs/tags/v", ""
        } elseif ("${{ github.event.inputs.version }}" -ne "") {
          $version = "${{ github.event.inputs.version }}"
        } else {
          $version = "dev-${{ github.sha }}"
        }
        echo "version=$version" >> $env:GITHUB_OUTPUT
        echo "Building version: $version"
      shell: powershell
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install NSIS
      run: |
        choco install nsis -y
        echo "C:\Program Files (x86)\NSIS" >> $env:GITHUB_PATH
      shell: powershell
      
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Install Node.js dependencies
      run: npm ci
      
    - name: Build frontend
      run: |
        if (Test-Path "src/frontend") {
          cd src/frontend
          npm ci
          npm run build
        } else {
          echo "Frontend directory not found, skipping frontend build"
        }
      
    - name: Create Windows installer
      run: |
        python scripts/create-distribution.py --platform windows --version ${{ steps.version.outputs.version }}
      shell: powershell
      
    - name: Generate checksums
      run: |
        $files = Get-ChildItem -Path "distribution\windows\*.exe"
        foreach ($file in $files) {
          $hash = Get-FileHash -Path $file.FullName -Algorithm SHA256
          "$($hash.Hash.ToLower())  $($file.Name)" | Out-File -Append -FilePath "distribution\windows\SHA256SUMS" -Encoding utf8
        }
      shell: powershell
      
    - name: Upload Windows artifacts
      uses: actions/upload-artifact@v4
      with:
        name: windows-installer
        path: |
          distribution/windows/*.exe
          distribution/windows/SHA256SUMS
        retention-days: 30

  build-macos:
    runs-on: macos-latest
    needs: build-windows
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Install Node.js dependencies
      run: npm ci
      
    - name: Build frontend
      run: |
        if [ -d "src/frontend" ]; then
          cd src/frontend
          npm ci
          npm run build
        else
          echo "Frontend directory not found, skipping frontend build"
        fi
      
    - name: Create macOS installer
      run: |
        python scripts/create-distribution.py --platform macos --version ${{ needs.build-windows.outputs.version }}
      
    - name: Generate checksums
      run: |
        echo "üîê Generating comprehensive checksums for macOS artifacts..."
        cd distribution/macos
        
        # Generate SHA256 checksums
        if ls *.dmg 1> /dev/null 2>&1; then
          shasum -a 256 *.dmg > SHA256SUMS
          echo "‚úÖ SHA256 checksums generated"
          
          # Also generate MD5 for additional verification
          md5 *.dmg > MD5SUMS 2>/dev/null || true
          
          # Display checksums for verification
          echo "üìã Generated checksums:"
          cat SHA256SUMS
          
          # Verify the checksums immediately
          echo "üîç Verifying generated checksums..."
          if shasum -a 256 -c SHA256SUMS; then
            echo "‚úÖ Checksum verification passed"
          else
            echo "‚ùå Checksum verification failed"
            exit 1
          fi
        else
          echo "‚ùå No DMG files found to checksum"
          exit 1
        fi
      
    - name: Upload macOS artifacts
      uses: actions/upload-artifact@v4
      with:
        name: macos-installer
        path: |
          distribution/macos/*.dmg
          distribution/macos/SHA256SUMS
          distribution/macos/MD5SUMS
        retention-days: 30

  build-linux:
    runs-on: ubuntu-latest
    needs: build-windows
    strategy:
      matrix:
        include:
          - name: "Ubuntu 20.04"
            container: "ubuntu:20.04"
            package_formats: "deb appimage"
          - name: "Ubuntu 22.04"
            container: "ubuntu:22.04"
            package_formats: "deb appimage"
          - name: "Fedora 38"
            container: "fedora:38"
            package_formats: "rpm appimage"
    
    container: ${{ matrix.container }}
    
    steps:
    - name: Install base dependencies (Ubuntu)
      if: startsWith(matrix.container, 'ubuntu')
      run: |
        export DEBIAN_FRONTEND=noninteractive
        apt-get update
        apt-get install -y curl git build-essential python3 python3-pip python3-dev \
          nodejs npm rpm alien fakeroot lintian desktop-file-utils \
          libfuse2 wget file
        
        # Install specific Node.js version
        curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
        apt-get install -y nodejs
        
    - name: Install base dependencies (Fedora)
      if: startsWith(matrix.container, 'fedora')
      run: |
        dnf update -y
        dnf install -y curl git gcc gcc-c++ make python3 python3-pip python3-devel \
          nodejs npm rpm-build rpmdevtools rpmlint alien fuse desktop-file-utils \
          wget file which
      
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python environment
      run: |
        python3 -m pip install --upgrade pip setuptools wheel
        python3 -m pip install -r requirements.txt
        
    - name: Install Node.js dependencies
      run: npm ci
      
    - name: Build frontend
      run: |
        if [ -d "src/frontend" ]; then
          cd src/frontend
          npm ci
          npm run build
        else
          echo "Frontend directory not found, skipping frontend build"
        fi
      
    - name: Prepare build environment
      run: |
        echo "üîß Preparing Linux build environment for ${{ matrix.name }}..."
        
        # Create distribution directory
        mkdir -p distribution/linux
        
        # Make installer scripts executable
        chmod +x installer/linux/*.sh
        
        # Verify required tools
        echo "üìã Checking build tools..."
        python3 --version
        node --version
        npm --version
        
        if echo "${{ matrix.package_formats }}" | grep -q "deb"; then
          dpkg --version || echo "‚ö†Ô∏è  dpkg not available"
          fakeroot --version || echo "‚ö†Ô∏è  fakeroot not available"
        fi
        
        if echo "${{ matrix.package_formats }}" | grep -q "rpm"; then
          rpm --version || echo "‚ö†Ô∏è  rpm not available"
          rpmbuild --version || echo "‚ö†Ô∏è  rpmbuild not available"
        fi
        
        echo "‚úÖ Build environment ready"
      
    - name: Create Linux packages
      run: |
        echo "üì¶ Creating Linux packages for ${{ matrix.name }}..."
        
        # Set version from build-windows job
        VERSION="${{ needs.build-windows.outputs.version }}"
        echo "Building version: $VERSION"
        
        # Create packages using the enhanced Linux build system
        if echo "${{ matrix.package_formats }}" | grep -q "deb"; then
          echo "üî® Building DEB package..."
          bash installer/linux/build_deb.sh "$(pwd)" "$(pwd)/distribution/linux" "$VERSION" --verbose || {
            echo "‚ùå DEB build failed, trying fallback..."
            python3 scripts/create-distribution.py --platform linux --version "$VERSION"
          }
        fi
        
        if echo "${{ matrix.package_formats }}" | grep -q "rpm"; then
          echo "üî® Building RPM package..."
          bash installer/linux/build_rpm.sh "$(pwd)" "$(pwd)/distribution/linux" "$VERSION" --verbose || {
            echo "‚ùå RPM build failed, trying fallback..."
            python3 scripts/create-distribution.py --platform linux --version "$VERSION"
          }
        fi
        
        if echo "${{ matrix.package_formats }}" | grep -q "appimage"; then
          echo "üî® Building AppImage..."
          bash installer/linux/build_appimage.sh "$(pwd)" "$(pwd)/distribution/linux" "$VERSION" --verbose || {
            echo "‚ùå AppImage build failed, trying fallback..."
            python3 scripts/create-distribution.py --platform linux --version "$VERSION"
          }
        fi
        
        echo "üìã Listing created packages:"
        ls -la distribution/linux/ || echo "No packages created"
      
    - name: Validate Linux packages
      run: |
        echo "üîç Validating created Linux packages..."
        cd distribution/linux
        
        # Validate DEB packages
        for deb_file in *.deb; do
          if [ -f "$deb_file" ]; then
            echo "üì¶ Validating DEB: $deb_file"
            
            # Check package structure
            dpkg --info "$deb_file" || echo "‚ö†Ô∏è  Could not read DEB info"
            dpkg --contents "$deb_file" | head -20 || echo "‚ö†Ô∏è  Could not list DEB contents"
            
            # Validate with lintian if available
            if command -v lintian >/dev/null 2>&1; then
              echo "üîç Running lintian validation..."
              lintian "$deb_file" || echo "‚ö†Ô∏è  Lintian found issues (may be non-critical)"
            fi
            
            echo "‚úÖ DEB validation completed"
          fi
        done
        
        # Validate RPM packages
        for rpm_file in *.rpm; do
          if [ -f "$rpm_file" ]; then
            echo "üì¶ Validating RPM: $rpm_file"
            
            # Check package structure
            rpm -qip "$rpm_file" || echo "‚ö†Ô∏è  Could not read RPM info"
            rpm -qlp "$rpm_file" | head -20 || echo "‚ö†Ô∏è  Could not list RPM contents"
            
            # Validate with rpmlint if available
            if command -v rpmlint >/dev/null 2>&1; then
              echo "üîç Running rpmlint validation..."
              rpmlint "$rpm_file" || echo "‚ö†Ô∏è  rpmlint found issues (may be non-critical)"
            fi
            
            echo "‚úÖ RPM validation completed"
          fi
        done
        
        # Validate AppImage
        for appimage_file in *.AppImage; do
          if [ -f "$appimage_file" ]; then
            echo "üì¶ Validating AppImage: $appimage_file"
            
            # Check if AppImage is executable
            if [ -x "$appimage_file" ]; then
              echo "‚úÖ AppImage is executable"
              
              # Try to extract and examine contents
              if timeout 30s "$appimage_file" --appimage-extract-and-run --help >/dev/null 2>&1; then
                echo "‚úÖ AppImage responds to --help"
              else
                echo "‚ö†Ô∏è  AppImage doesn't respond to --help (may be normal)"
              fi
            else
              echo "‚ùå AppImage is not executable"
              chmod +x "$appimage_file"
            fi
            
            echo "‚úÖ AppImage validation completed"
          fi
        done
        
        echo "‚úÖ Package validation completed"
      
    - name: Generate comprehensive checksums
      run: |
        echo "üîê Generating comprehensive checksums for Linux packages..."
        cd distribution/linux
        
        # Generate SHA256 checksums for all package types
        if ls *.deb *.rpm *.AppImage *.tar.gz 2>/dev/null; then
          sha256sum *.deb *.rpm *.AppImage *.tar.gz 2>/dev/null > SHA256SUMS || \
          sha256sum * 2>/dev/null > SHA256SUMS || \
          echo "‚ö†Ô∏è  No packages found to checksum"
          
          # Also generate MD5 for additional verification
          md5sum *.deb *.rpm *.AppImage *.tar.gz 2>/dev/null > MD5SUMS || \
          md5sum * 2>/dev/null > MD5SUMS || true
          
          # Display checksums for verification
          if [ -f SHA256SUMS ]; then
            echo "üìã Generated SHA256 checksums:"
            cat SHA256SUMS
            
            # Verify the checksums immediately
            echo "üîç Verifying generated checksums..."
            if sha256sum -c SHA256SUMS; then
              echo "‚úÖ Checksum verification passed"
            else
              echo "‚ùå Checksum verification failed"
              exit 1
            fi
          else
            echo "‚ùå No SHA256SUMS file generated"
            exit 1
          fi
        else
          echo "‚ùå No packages found to checksum"
          exit 1
        fi
      
    - name: Upload Linux artifacts
      uses: actions/upload-artifact@v4
      with:
        name: linux-packages-${{ matrix.name }}
        path: |
          distribution/linux/*.deb
          distribution/linux/*.rpm
          distribution/linux/*.AppImage
          distribution/linux/*.tar.gz
          distribution/linux/SHA256SUMS
          distribution/linux/MD5SUMS
        retention-days: 30
        
    - name: Create build summary
      run: |
        echo "üìä Build Summary for ${{ matrix.name }}:"
        echo "======================================"
        
        cd distribution/linux
        
        echo "üì¶ Created packages:"
        for file in *.deb *.rpm *.AppImage *.tar.gz; do
          if [ -f "$file" ]; then
            size=$(du -h "$file" | cut -f1)
            echo "  ‚úÖ $file ($size)"
          fi
        done
        
        echo ""
        echo "üîê Checksums available:"
        [ -f SHA256SUMS ] && echo "  ‚úÖ SHA256SUMS" || echo "  ‚ùå SHA256SUMS missing"
        [ -f MD5SUMS ] && echo "  ‚úÖ MD5SUMS" || echo "  ‚ùå MD5SUMS missing"
        
        echo ""
        echo "‚úÖ Linux build completed for ${{ matrix.name }}"

  validate-macos:
    needs: [build-macos]
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download macOS artifacts
      uses: actions/download-artifact@v4
      with:
        name: macos-installer
        path: artifacts/
        
    - name: Validate macOS DMG structure
      run: |
        echo "üîç Running comprehensive macOS DMG validation..."
        
        dmg_file=$(find artifacts -name "*.dmg" | head -1)
        if [ -z "$dmg_file" ]; then
          echo "‚ùå No DMG file found"
          exit 1
        fi
        
        echo "üìÅ Validating DMG: $(basename "$dmg_file")"
        
        # Check DMG file size (should be reasonable)
        dmg_size=$(stat -f%z "$dmg_file" 2>/dev/null || echo "0")
        echo "üìè DMG size: $dmg_size bytes"
        
        if [ "$dmg_size" -lt 10000000 ]; then  # Less than 10MB might be too small
          echo "‚ö†Ô∏è  Warning: DMG seems small ($dmg_size bytes)"
        fi
        
        if [ "$dmg_size" -gt 500000000 ]; then  # More than 500MB might be too large
          echo "‚ö†Ô∏è  Warning: DMG seems large ($dmg_size bytes)"
        fi
        
        # Verify checksum file exists and is valid
        checksum_file=$(find artifacts -name "SHA256SUMS" | head -1)
        if [ -n "$checksum_file" ]; then
          echo "üîê Verifying checksum..."
          cd "$(dirname "$checksum_file")"
          if shasum -a 256 -c SHA256SUMS; then
            echo "‚úÖ Checksum verification passed"
          else
            echo "‚ùå Checksum verification failed"
            exit 1
          fi
          cd - > /dev/null
        else
          echo "‚ùå No checksum file found"
          exit 1
        fi
        
        # Mount and perform detailed validation
        mount_point="/tmp/validate_mount_$(date +%s)"
        echo "üíæ Mounting DMG at $mount_point..."
        
        if ! hdiutil attach "$dmg_file" -mountpoint "$mount_point" -readonly -nobrowse; then
          echo "‚ùå Failed to mount DMG"
          exit 1
        fi
        
        # Validate DMG contents
        app_bundle="$mount_point/Bitcoin Solo Miner Monitor.app"
        
        echo "üîç Performing detailed app bundle validation..."
        
        # Check bundle identifier
        bundle_id=$(plutil -extract CFBundleIdentifier raw "$app_bundle/Contents/Info.plist" 2>/dev/null || echo "unknown")
        echo "üÜî Bundle ID: $bundle_id"
        
        # Check minimum system version
        min_version=$(plutil -extract LSMinimumSystemVersion raw "$app_bundle/Contents/Info.plist" 2>/dev/null || echo "unknown")
        echo "üñ•Ô∏è  Minimum macOS version: $min_version"
        
        # Validate executable architecture
        executable="$app_bundle/Contents/MacOS/BitcoinSoloMinerMonitor"
        if [ -f "$executable" ]; then
          echo "üèóÔ∏è  Checking executable architecture..."
          file "$executable"
          
          # Check if it's a script or binary
          if file "$executable" | grep -q "shell script"; then
            echo "‚úÖ Executable is a shell script (expected for Python app)"
            
            # Validate shell script syntax
            if bash -n "$executable"; then
              echo "‚úÖ Shell script syntax is valid"
            else
              echo "‚ùå Shell script has syntax errors"
              hdiutil detach "$mount_point" || true
              exit 1
            fi
          else
            echo "‚ÑπÔ∏è  Executable is not a shell script"
          fi
        fi
        
        # Check for Python dependencies structure
        echo "üêç Checking Python environment setup..."
        if [ -d "$app_bundle/Contents/Resources/site-packages" ]; then
          echo "‚úÖ Site-packages directory found"
          package_count=$(find "$app_bundle/Contents/Resources/site-packages" -maxdepth 1 -type d | wc -l)
          echo "üì¶ Found $package_count package directories"
        else
          echo "‚ö†Ô∏è  Site-packages directory not found (dependencies may be handled differently)"
        fi
        
        # Check for Python framework
        if [ -d "$app_bundle/Contents/Frameworks/Python.framework" ]; then
          echo "‚úÖ Python framework found in bundle"
        else
          echo "‚ÑπÔ∏è  No bundled Python framework (may use system Python)"
        fi
        
        # Validate application resources
        echo "üìö Checking application resources..."
        resources_dir="$app_bundle/Contents/Resources"
        
        essential_files=("run.py" "src" "config")
        for file in "${essential_files[@]}"; do
          if [ -e "$resources_dir/$file" ]; then
            echo "‚úÖ Found: $file"
          else
            echo "‚ö†Ô∏è  Missing: $file"
          fi
        done
        
        # Check for icon file
        if [ -f "$app_bundle/Contents/Resources/app_icon.icns" ]; then
          echo "‚úÖ App icon found (ICNS format)"
        elif [ -f "$app_bundle/Contents/Resources/app_icon.png" ]; then
          echo "‚úÖ App icon found (PNG format)"
        else
          echo "‚ö†Ô∏è  No app icon found"
        fi
        
        # Test DMG user experience elements
        echo "üë§ Checking user experience elements..."
        
        if [ -L "$mount_point/Applications" ]; then
          echo "‚úÖ Applications symlink present"
          if [ "$(readlink "$mount_point/Applications")" = "/Applications" ]; then
            echo "‚úÖ Applications symlink points to correct location"
          else
            echo "‚ùå Applications symlink points to wrong location"
            hdiutil detach "$mount_point" || true
            exit 1
          fi
        else
          echo "‚ùå Applications symlink missing"
          hdiutil detach "$mount_point" || true
          exit 1
        fi
        
        if [ -f "$mount_point/Installation Instructions.txt" ]; then
          echo "‚úÖ Installation instructions present"
          # Check if instructions are not empty
          if [ -s "$mount_point/Installation Instructions.txt" ]; then
            echo "‚úÖ Installation instructions are not empty"
          else
            echo "‚ö†Ô∏è  Installation instructions file is empty"
          fi
        else
          echo "‚ö†Ô∏è  Installation instructions missing"
        fi
        
        # Check for background image
        if [ -f "$mount_point/.background/background.png" ]; then
          echo "‚úÖ DMG background image found"
        else
          echo "‚ÑπÔ∏è  No custom DMG background image"
        fi
        
        # Unmount DMG
        echo "üì§ Unmounting DMG..."
        if ! hdiutil detach "$mount_point"; then
          echo "‚ö†Ô∏è  Warning: Could not unmount cleanly, forcing..."
          hdiutil detach "$mount_point" -force || true
        fi
        
        echo "‚úÖ macOS DMG validation completed successfully"
        
    - name: Test macOS system integration
      run: |
        echo "üîß Testing macOS system integration capabilities..."
        
        # Test Spotlight indexing compatibility
        echo "üîç Checking Spotlight compatibility..."
        dmg_file=$(find artifacts -name "*.dmg" | head -1)
        mount_point="/tmp/spotlight_test_$(date +%s)"
        
        hdiutil attach "$dmg_file" -mountpoint "$mount_point" -readonly -nobrowse
        app_bundle="$mount_point/Bitcoin Solo Miner Monitor.app"
        
        # Check if mdls can read the bundle metadata
        if mdls "$app_bundle" >/dev/null 2>&1; then
          echo "‚úÖ App bundle is Spotlight compatible"
        else
          echo "‚ö†Ô∏è  App bundle may have Spotlight indexing issues"
        fi
        
        # Test Launch Services compatibility
        echo "üöÄ Checking Launch Services compatibility..."
        if /System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -dump | grep -q "Bitcoin Solo Miner Monitor" 2>/dev/null; then
          echo "‚ÑπÔ∏è  App may already be registered with Launch Services"
        else
          echo "‚ÑπÔ∏è  App not currently registered with Launch Services (normal for testing)"
        fi
        
        hdiutil detach "$mount_point" || true
        
        echo "‚úÖ macOS system integration tests completed"

  test-installers:
    needs: [build-windows, build-macos, build-linux, validate-macos]
    strategy:
      matrix:
        os: [windows-latest, macos-latest, ubuntu-latest]
    runs-on: ${{ matrix.os }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
        
    - name: Test Windows installer
      if: matrix.os == 'windows-latest'
      run: |
        $installer = Get-ChildItem -Path "artifacts\windows-installer\*.exe" | Select-Object -First 1
        if ($installer) {
          echo "Testing Windows installer: $($installer.Name)"
          # Test installer in silent mode
          Start-Process -FilePath $installer.FullName -ArgumentList "/S" -Wait -NoNewWindow
          # Verify installation
          if (Test-Path "C:\Program Files\Bitcoin Solo Miner Monitor\BitcoinSoloMinerMonitor.exe") {
            echo "‚úì Windows installer test passed"
          } else {
            echo "‚úó Windows installer test failed"
            exit 1
          }
        }
      shell: powershell
      
    - name: Test macOS installer
      if: matrix.os == 'macos-latest'
      run: |
        dmg_file=$(find artifacts/macos-installer -name "*.dmg" | head -1)
        if [ -n "$dmg_file" ]; then
          echo "üçé Testing macOS installer: $(basename "$dmg_file")"
          
          # Verify DMG file integrity
          echo "üìã Verifying DMG integrity..."
          if ! hdiutil verify "$dmg_file"; then
            echo "‚ùå DMG integrity check failed"
            exit 1
          fi
          echo "‚úÖ DMG integrity verified"
          
          # Mount DMG and verify contents
          echo "üíæ Mounting DMG for content verification..."
          mount_point="/tmp/test_mount_$(date +%s)"
          if ! hdiutil attach "$dmg_file" -mountpoint "$mount_point" -readonly; then
            echo "‚ùå Failed to mount DMG"
            exit 1
          fi
          
          # Verify app bundle structure
          app_bundle="$mount_point/Bitcoin Solo Miner Monitor.app"
          if [ ! -d "$app_bundle" ]; then
            echo "‚ùå App bundle not found in DMG"
            hdiutil detach "$mount_point" || true
            exit 1
          fi
          echo "‚úÖ App bundle found: $app_bundle"
          
          # Verify essential app bundle components
          echo "üîç Verifying app bundle structure..."
          
          # Check Info.plist
          if [ ! -f "$app_bundle/Contents/Info.plist" ]; then
            echo "‚ùå Info.plist missing"
            hdiutil detach "$mount_point" || true
            exit 1
          fi
          echo "‚úÖ Info.plist found"
          
          # Check executable
          if [ ! -f "$app_bundle/Contents/MacOS/BitcoinSoloMinerMonitor" ]; then
            echo "‚ùå Main executable missing"
            hdiutil detach "$mount_point" || true
            exit 1
          fi
          
          # Verify executable permissions
          if [ ! -x "$app_bundle/Contents/MacOS/BitcoinSoloMinerMonitor" ]; then
            echo "‚ùå Main executable not executable"
            hdiutil detach "$mount_point" || true
            exit 1
          fi
          echo "‚úÖ Main executable found and executable"
          
          # Check Resources directory
          if [ ! -d "$app_bundle/Contents/Resources" ]; then
            echo "‚ùå Resources directory missing"
            hdiutil detach "$mount_point" || true
            exit 1
          fi
          echo "‚úÖ Resources directory found"
          
          # Verify essential application files
          if [ ! -f "$app_bundle/Contents/Resources/run.py" ]; then
            echo "‚ùå Main Python script (run.py) missing"
            hdiutil detach "$mount_point" || true
            exit 1
          fi
          echo "‚úÖ Main Python script found"
          
          # Check for requirements.txt
          if [ ! -f "$app_bundle/Contents/Resources/requirements.txt" ]; then
            echo "‚ö†Ô∏è  requirements.txt missing (may be bundled differently)"
          else
            echo "‚úÖ requirements.txt found"
          fi
          
          # Verify Applications symlink
          if [ ! -L "$mount_point/Applications" ]; then
            echo "‚ùå Applications symlink missing"
            hdiutil detach "$mount_point" || true
            exit 1
          fi
          echo "‚úÖ Applications symlink found"
          
          # Check for installation instructions
          if [ -f "$mount_point/Installation Instructions.txt" ]; then
            echo "‚úÖ Installation instructions found"
          else
            echo "‚ö†Ô∏è  Installation instructions missing"
          fi
          
          # Test app bundle validation (basic)
          echo "üîç Running basic app bundle validation..."
          if ! codesign --verify --deep --strict "$app_bundle" 2>/dev/null; then
            echo "‚ö†Ô∏è  App bundle not code signed (expected for open source)"
          else
            echo "‚úÖ App bundle code signature valid"
          fi
          
          # Test Info.plist parsing
          echo "üìã Validating Info.plist..."
          if ! plutil -lint "$app_bundle/Contents/Info.plist" >/dev/null 2>&1; then
            echo "‚ùå Info.plist is malformed"
            hdiutil detach "$mount_point" || true
            exit 1
          fi
          echo "‚úÖ Info.plist is valid"
          
          # Extract and verify version info
          bundle_version=$(plutil -extract CFBundleShortVersionString raw "$app_bundle/Contents/Info.plist" 2>/dev/null || echo "unknown")
          echo "üì¶ Bundle version: $bundle_version"
          
          # Test executable basic functionality (dry run)
          echo "üß™ Testing executable basic functionality..."
          if timeout 10s "$app_bundle/Contents/MacOS/BitcoinSoloMinerMonitor" --help >/dev/null 2>&1; then
            echo "‚úÖ Executable responds to --help"
          else
            echo "‚ö†Ô∏è  Executable doesn't respond to --help (may be normal)"
          fi
          
          # Unmount DMG
          echo "üì§ Unmounting DMG..."
          if ! hdiutil detach "$mount_point"; then
            echo "‚ö†Ô∏è  Warning: Could not unmount cleanly"
            hdiutil detach "$mount_point" -force || true
          fi
          
          echo "‚úÖ macOS installer test completed successfully"
        else
          echo "‚ùå No macOS DMG file found in artifacts"
          exit 1
        fi
      
    - name: Test Linux packages
      if: matrix.os == 'ubuntu-latest'
      run: |
        echo "üêß Testing Linux packages..."
        
        # Test all available Linux packages from different distributions
        package_tested=false
        
        # Test DEB packages
        for deb_dir in artifacts/linux-packages-*/; do
          if [ -d "$deb_dir" ]; then
            echo "üìÅ Checking directory: $deb_dir"
            
            for deb_file in "$deb_dir"*.deb; do
              if [ -f "$deb_file" ]; then
                echo "üì¶ Testing DEB package: $(basename "$deb_file")"
                
                # Verify package structure
                if dpkg --info "$deb_file" >/dev/null 2>&1; then
                  echo "‚úÖ DEB package structure is valid"
                  
                  # Test dry-run installation
                  if sudo dpkg --dry-run -i "$deb_file" >/dev/null 2>&1; then
                    echo "‚úÖ DEB package dry-run installation successful"
                    package_tested=true
                  else
                    echo "‚ö†Ô∏è  DEB package dry-run installation failed (may need dependencies)"
                    package_tested=true  # Still count as tested
                  fi
                  
                  # Check package contents
                  echo "üìã Package contents preview:"
                  dpkg --contents "$deb_file" | head -10
                  
                else
                  echo "‚ùå DEB package structure is invalid"
                  exit 1
                fi
                
                break  # Test only first DEB found
              fi
            done
          fi
        done
        
        # Test AppImage packages
        for appimage_dir in artifacts/linux-packages-*/; do
          if [ -d "$appimage_dir" ]; then
            for appimage_file in "$appimage_dir"*.AppImage; do
              if [ -f "$appimage_file" ]; then
                echo "üì¶ Testing AppImage: $(basename "$appimage_file")"
                
                # Make executable if not already
                chmod +x "$appimage_file"
                
                # Test basic AppImage functionality
                if timeout 10s "$appimage_file" --help >/dev/null 2>&1; then
                  echo "‚úÖ AppImage responds to --help"
                  package_tested=true
                elif timeout 10s "$appimage_file" --version >/dev/null 2>&1; then
                  echo "‚úÖ AppImage responds to --version"
                  package_tested=true
                else
                  echo "‚ö†Ô∏è  AppImage doesn't respond to standard flags (may be normal)"
                  package_tested=true  # Still count as tested
                fi
                
                # Check if AppImage can be extracted
                if "$appimage_file" --appimage-help >/dev/null 2>&1; then
                  echo "‚úÖ AppImage supports extraction"
                else
                  echo "‚ö†Ô∏è  AppImage extraction not supported (may be normal)"
                fi
                
                break  # Test only first AppImage found
              fi
            done
          fi
        done
        
        # Verify checksums for all Linux packages
        echo "üîê Verifying Linux package checksums..."
        checksum_verified=false
        
        for checksum_dir in artifacts/linux-packages-*/; do
          if [ -d "$checksum_dir" ] && [ -f "${checksum_dir}SHA256SUMS" ]; then
            echo "üìã Verifying checksums in: $checksum_dir"
            
            cd "$checksum_dir"
            if sha256sum -c SHA256SUMS >/dev/null 2>&1; then
              echo "‚úÖ Checksum verification passed"
              checksum_verified=true
            else
              echo "‚ùå Checksum verification failed"
              exit 1
            fi
            cd - >/dev/null
          fi
        done
        
        # Final validation
        if [ "$package_tested" = true ]; then
          echo "‚úÖ Linux package testing completed successfully"
        else
          echo "‚ùå No Linux packages were tested"
          exit 1
        fi
        
        if [ "$checksum_verified" = true ]; then
          echo "‚úÖ Linux checksum verification completed successfully"
        else
          echo "‚ö†Ô∏è  No checksums were verified (may be missing)"
        fi

  create-release:
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    needs: [build-windows, build-macos, build-linux, validate-macos, test-installers]
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
        
    - name: Prepare release assets
      run: |
        mkdir -p release-assets
        
        # Copy Windows installer
        cp artifacts/windows-installer/*.exe release-assets/ 2>/dev/null || true
        
        # Copy macOS installer
        cp artifacts/macos-installer/*.dmg release-assets/ 2>/dev/null || true
        
        # Copy Linux packages from all distributions
        echo "üì¶ Collecting Linux packages from all distributions..."
        for linux_dir in artifacts/linux-packages-*/; do
          if [ -d "$linux_dir" ]; then
            echo "üìÅ Processing: $linux_dir"
            
            # Copy packages with distribution suffix to avoid conflicts
            dist_name=$(basename "$linux_dir" | sed 's/linux-packages-//')
            
            # Copy DEB packages
            for deb_file in "$linux_dir"*.deb; do
              if [ -f "$deb_file" ]; then
                base_name=$(basename "$deb_file" .deb)
                new_name="${base_name}-${dist_name}.deb"
                cp "$deb_file" "release-assets/$new_name"
                echo "‚úÖ Copied: $new_name"
              fi
            done
            
            # Copy RPM packages
            for rpm_file in "$linux_dir"*.rpm; do
              if [ -f "$rpm_file" ]; then
                base_name=$(basename "$rpm_file" .rpm)
                new_name="${base_name}-${dist_name}.rpm"
                cp "$rpm_file" "release-assets/$new_name"
                echo "‚úÖ Copied: $new_name"
              fi
            done
            
            # Copy AppImage (only one needed, prefer Ubuntu 22.04)
            for appimage_file in "$linux_dir"*.AppImage; do
              if [ -f "$appimage_file" ] && [ ! -f "release-assets/$(basename "$appimage_file")" ]; then
                cp "$appimage_file" "release-assets/"
                echo "‚úÖ Copied: $(basename "$appimage_file")"
                break  # Only copy first AppImage found
              fi
            done
            
            # Copy TAR.GZ packages
            for tar_file in "$linux_dir"*.tar.gz; do
              if [ -f "$tar_file" ]; then
                base_name=$(basename "$tar_file" .tar.gz)
                new_name="${base_name}-${dist_name}.tar.gz"
                cp "$tar_file" "release-assets/$new_name"
                echo "‚úÖ Copied: $new_name"
              fi
            done
          fi
        done
        
        # Combine all checksums into a master checksum file
        echo "üîê Creating master checksum file..."
        > release-assets/SHA256SUMS  # Create empty file
        
        # Add checksums from all artifacts
        for checksum_file in artifacts/*/SHA256SUMS; do
          if [ -f "$checksum_file" ]; then
            echo "# Checksums from $(dirname "$checksum_file")" >> release-assets/SHA256SUMS
            cat "$checksum_file" >> release-assets/SHA256SUMS
            echo "" >> release-assets/SHA256SUMS
          fi
        done
        
        # Generate checksums for any files that don't have them
        cd release-assets
        for file in *.exe *.dmg *.deb *.rpm *.AppImage *.tar.gz; do
          if [ -f "$file" ] && ! grep -q "$file" SHA256SUMS 2>/dev/null; then
            echo "üîê Generating checksum for: $file"
            sha256sum "$file" >> SHA256SUMS
          fi
        done
        cd ..
        
        # List all release assets
        echo "üìã Final release assets:"
        ls -la release-assets/
      
    - name: Generate release notes
      id: release_notes
      run: |
        VERSION=${{ needs.build-windows.outputs.version }}
        echo "## Bitcoin Solo Miner Monitor v${VERSION}" > release_notes.md
        echo "" >> release_notes.md
        echo "### Downloads" >> release_notes.md
        echo "" >> release_notes.md
        
        # Add download links for each platform
        for file in release-assets/*; do
          if [ -f "$file" ] && [ "$(basename "$file")" != "SHA256SUMS" ]; then
            filename=$(basename "$file")
            echo "- **${filename}**" >> release_notes.md
          fi
        done
        
        echo "" >> release_notes.md
        echo "### Verification" >> release_notes.md
        echo "" >> release_notes.md
        echo "All downloads include SHA256 checksums for verification. Download the \`SHA256SUMS\` file and verify your download:" >> release_notes.md
        echo "" >> release_notes.md
        echo "\`\`\`bash" >> release_notes.md
        echo "# On Windows (PowerShell):" >> release_notes.md
        echo "Get-FileHash -Algorithm SHA256 <filename>" >> release_notes.md
        echo "" >> release_notes.md
        echo "# On macOS/Linux:" >> release_notes.md
        echo "shasum -a 256 <filename>" >> release_notes.md
        echo "\`\`\`" >> release_notes.md
        echo "" >> release_notes.md
        echo "### Installation Instructions" >> release_notes.md
        echo "" >> release_notes.md
        echo "- **Windows**: Download the .exe file and run it. Windows may show an \"Unknown Publisher\" warning - this is normal for open-source software." >> release_notes.md
        echo "- **macOS**: Download the .dmg file, open it, and drag the application to your Applications folder." >> release_notes.md
        echo "- **Linux**: Download the appropriate package (.deb for Ubuntu/Debian, .rpm for Fedora/CentOS, or .AppImage for universal compatibility)." >> release_notes.md
        
        # Set output for GitHub release
        echo "RELEASE_NOTES<<EOF" >> $GITHUB_OUTPUT
        cat release_notes.md >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
      
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ github.ref_name }}
        name: Bitcoin Solo Miner Monitor ${{ needs.build-windows.outputs.version }}
        body: ${{ steps.release_notes.outputs.RELEASE_NOTES }}
        files: release-assets/*
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  security-scan:
    needs: [build-windows, build-macos, build-linux, validate-macos]
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
        
    - name: Run comprehensive security scan
      run: |
        echo "üîí Running comprehensive security scans on generated installers..."
        
        # Verify checksums for all platforms
        echo "üîê Verifying checksums across all platforms..."
        checksum_errors=0
        
        for checksum_file in artifacts/*/SHA256SUMS; do
          if [ -f "$checksum_file" ]; then
            echo "üìã Checking $(dirname "$checksum_file"):"
            cd "$(dirname "$checksum_file")"
            
            if sha256sum -c SHA256SUMS 2>/dev/null; then
              echo "‚úÖ Checksum verification passed"
            else
              echo "‚ùå Checksum verification failed for $(dirname "$checksum_file")"
              checksum_errors=$((checksum_errors + 1))
            fi
            cd - > /dev/null
          fi
        done
        
        if [ $checksum_errors -gt 0 ]; then
          echo "‚ùå $checksum_errors checksum verification(s) failed"
          exit 1
        else
          echo "‚úÖ All checksum verifications passed"
        fi
        
        # Check file sizes and basic security properties
        echo "üìã Performing security analysis on installer files..."
        
        # Windows executables
        find artifacts -name "*.exe" | while read file; do
          if [ -f "$file" ]; then
            size=$(stat -c%s "$file" 2>/dev/null || echo "0")
            echo "üíª Windows installer: $(basename "$file")"
            
            if [ "$size" -lt 5000000 ]; then  # Less than 5MB is suspicious for bundled app
              echo "‚ö†Ô∏è  Warning: $file is only $size bytes (may be incomplete)"
            elif [ "$size" -gt 500000000 ]; then  # More than 500MB is very large
              echo "‚ö†Ô∏è  Warning: $file is $size bytes (unusually large)"
            else
              echo "‚úÖ Size: $size bytes (reasonable)"
            fi
            
            # Check if file is executable
            if file "$file" | grep -q "executable"; then
              echo "‚úÖ File type: Windows executable"
            else
              echo "‚ö†Ô∏è  File type: Not recognized as Windows executable"
            fi
          fi
        done
        
        # macOS DMG files
        find artifacts -name "*.dmg" | while read file; do
          if [ -f "$file" ]; then
            size=$(stat -c%s "$file" 2>/dev/null || echo "0")
            echo "üçé macOS installer: $(basename "$file")"
            
            if [ "$size" -lt 10000000 ]; then  # Less than 10MB is suspicious
              echo "‚ö†Ô∏è  Warning: $file is only $size bytes (may be incomplete)"
            elif [ "$size" -gt 500000000 ]; then  # More than 500MB is very large
              echo "‚ö†Ô∏è  Warning: $file is $size bytes (unusually large)"
            else
              echo "‚úÖ Size: $size bytes (reasonable)"
            fi
            
            # Check if file is recognized as DMG
            if file "$file" | grep -q "disk image"; then
              echo "‚úÖ File type: macOS disk image"
            else
              echo "‚ö†Ô∏è  File type: Not recognized as macOS disk image"
            fi
          fi
        done
        
        # Linux packages
        echo "üêß Analyzing Linux packages..."
        
        # DEB packages
        find artifacts -name "*.deb" | while read file; do
          if [ -f "$file" ]; then
            size=$(stat -c%s "$file" 2>/dev/null || echo "0")
            echo "üì¶ DEB package: $(basename "$file")"
            
            if [ "$size" -lt 1000000 ]; then  # Less than 1MB is suspicious
              echo "‚ö†Ô∏è  Warning: $file is only $size bytes (may be incomplete)"
            else
              echo "‚úÖ Size: $size bytes"
            fi
            
            # Verify DEB package structure
            if dpkg --info "$file" >/dev/null 2>&1; then
              echo "‚úÖ DEB structure: Valid"
              
              # Check package metadata
              package_name=$(dpkg --field "$file" Package 2>/dev/null || echo "unknown")
              version=$(dpkg --field "$file" Version 2>/dev/null || echo "unknown")
              echo "üìù Package: $package_name, Version: $version"
            else
              echo "‚ùå DEB structure: Invalid"
            fi
          fi
        done
        
        # RPM packages
        find artifacts -name "*.rpm" | while read file; do
          if [ -f "$file" ]; then
            size=$(stat -c%s "$file" 2>/dev/null || echo "0")
            echo "üì¶ RPM package: $(basename "$file")"
            
            if [ "$size" -lt 1000000 ]; then  # Less than 1MB is suspicious
              echo "‚ö†Ô∏è  Warning: $file is only $size bytes (may be incomplete)"
            else
              echo "‚úÖ Size: $size bytes"
            fi
            
            # Verify RPM package structure
            if rpm -qip "$file" >/dev/null 2>&1; then
              echo "‚úÖ RPM structure: Valid"
              
              # Check package metadata
              package_name=$(rpm -qp --queryformat '%{NAME}' "$file" 2>/dev/null || echo "unknown")
              version=$(rpm -qp --queryformat '%{VERSION}' "$file" 2>/dev/null || echo "unknown")
              echo "üìù Package: $package_name, Version: $version"
            else
              echo "‚ùå RPM structure: Invalid"
            fi
          fi
        done
        
        # AppImage files
        find artifacts -name "*.AppImage" | while read file; do
          if [ -f "$file" ]; then
            size=$(stat -c%s "$file" 2>/dev/null || echo "0")
            echo "üì¶ AppImage: $(basename "$file")"
            
            if [ "$size" -lt 5000000 ]; then  # Less than 5MB is suspicious
              echo "‚ö†Ô∏è  Warning: $file is only $size bytes (may be incomplete)"
            else
              echo "‚úÖ Size: $size bytes"
            fi
            
            # Check if AppImage is executable
            if [ -x "$file" ]; then
              echo "‚úÖ Executable: Yes"
            else
              echo "‚ö†Ô∏è  Executable: No (fixing permissions)"
              chmod +x "$file"
            fi
            
            # Check AppImage type
            if file "$file" | grep -q "ELF"; then
              echo "‚úÖ File type: ELF executable (AppImage)"
            else
              echo "‚ö†Ô∏è  File type: Not recognized as ELF executable"
            fi
          fi
        done
        
        # Summary
        echo ""
        echo "üìã Security Scan Summary:"
        echo "========================"
        
        total_files=0
        for ext in "exe" "dmg" "deb" "rpm" "AppImage"; do
          count=$(find artifacts -name "*.$ext" | wc -l)
          total_files=$((total_files + count))
          echo "üì¶ $ext files: $count"
        done
        
        echo "üì¶ Total installer files: $total_files"
        
        if [ $total_files -eq 0 ]; then
          echo "‚ùå No installer files found - build may have failed"
          exit 1
        else
          echo "‚úÖ Security scan completed successfully"
        fi